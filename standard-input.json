{
  "language": "Solidity",
  "sources": {
    "contracts/SkunkSquadNFTSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"erc721a/contracts/ERC721A.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\n/**\r\n * @title SkunkSquadNFT 2.0\r\n * @dev Simplified NFT contract focusing on core functionality\r\n */\r\ncontract SkunkSquadNFTSimple is ERC721A, Ownable, ReentrancyGuard {\r\n    using Strings for uint256;\r\n\r\n    // =============================================================\r\n    //                           STORAGE\r\n    // =============================================================\r\n    \r\n    uint256 public constant MAX_SUPPLY = 10000;\r\n    uint256 public constant MAX_PER_WALLET = 20;\r\n    uint256 public constant MAX_PER_TX = 10;\r\n    \r\n    uint256 public mintPrice = 0.01 ether;\r\n    bool public mintingEnabled = false;\r\n    \r\n    string private baseTokenURI;\r\n    \r\n    // Track mints per wallet\r\n    mapping(address => uint256) public walletMints;\r\n    \r\n    // =============================================================\r\n    //                          EVENTS\r\n    // =============================================================\r\n    \r\n    event MintingToggled(bool enabled);\r\n    event PriceUpdated(uint256 newPrice);\r\n    event BaseURIUpdated(string newBaseURI);\r\n    \r\n    // =============================================================\r\n    //                        CONSTRUCTOR\r\n    // =============================================================\r\n    \r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _initialBaseURI\r\n    ) ERC721A(_name, _symbol) {\r\n        baseTokenURI = _initialBaseURI;\r\n    }\r\n    \r\n    // =============================================================\r\n    //                      MINTING FUNCTIONS\r\n    // =============================================================\r\n    \r\n    /**\r\n     * @notice Public mint function\r\n     * @param quantity Number of NFTs to mint\r\n     */\r\n    function mint(uint256 quantity) \r\n        external \r\n        payable \r\n        nonReentrant \r\n    {\r\n        require(mintingEnabled, \"Minting is not enabled\");\r\n        require(quantity > 0, \"Must mint at least 1\");\r\n        require(quantity <= MAX_PER_TX, \"Exceeds max per transaction\");\r\n        require(_totalMinted() + quantity <= MAX_SUPPLY, \"Exceeds max supply\");\r\n        require(walletMints[msg.sender] + quantity <= MAX_PER_WALLET, \"Exceeds max per wallet\");\r\n        require(msg.value >= mintPrice * quantity, \"Insufficient payment\");\r\n        \r\n        walletMints[msg.sender] += quantity;\r\n        _mint(msg.sender, quantity);\r\n    }\r\n    \r\n    /**\r\n     * @notice Owner mint for team/giveaways\r\n     * @param to Address to mint to\r\n     * @param quantity Number to mint\r\n     */\r\n    function ownerMint(address to, uint256 quantity) \r\n        external \r\n        onlyOwner \r\n    {\r\n        require(_totalMinted() + quantity <= MAX_SUPPLY, \"Exceeds max supply\");\r\n        _mint(to, quantity);\r\n    }\r\n    \r\n    // =============================================================\r\n    //                      ADMIN FUNCTIONS\r\n    // =============================================================\r\n    \r\n    /**\r\n     * @notice Toggle minting on/off\r\n     */\r\n    function toggleMinting() external onlyOwner {\r\n        mintingEnabled = !mintingEnabled;\r\n        emit MintingToggled(mintingEnabled);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update mint price\r\n     * @param newPrice New price in wei\r\n     */\r\n    function setMintPrice(uint256 newPrice) external onlyOwner {\r\n        mintPrice = newPrice;\r\n        emit PriceUpdated(newPrice);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set base URI for metadata\r\n     * @param newBaseURI New base URI\r\n     */\r\n    function setBaseURI(string memory newBaseURI) external onlyOwner {\r\n        baseTokenURI = newBaseURI;\r\n        emit BaseURIUpdated(newBaseURI);\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw contract balance\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No balance to withdraw\");\r\n        \r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n    \r\n    // =============================================================\r\n    //                       VIEW FUNCTIONS\r\n    // =============================================================\r\n    \r\n    /**\r\n     * @notice Get token URI\r\n     * @param tokenId Token ID\r\n     */\r\n    function tokenURI(uint256 tokenId) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (string memory) \r\n    {\r\n        require(_exists(tokenId), \"Token does not exist\");\r\n        \r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0\r\n            ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"))\r\n            : \"\";\r\n    }\r\n    \r\n    /**\r\n     * @notice Get base URI\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n    \r\n    /**\r\n     * @notice Starting token ID (1 instead of 0)\r\n     */\r\n    function _startTokenId() internal pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get total minted\r\n     */\r\n    function totalMinted() external view returns (uint256) {\r\n        return _totalMinted();\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if address can mint quantity\r\n     * @param account Address to check\r\n     * @param quantity Quantity to mint\r\n     */\r\n    function canMint(address account, uint256 quantity) \r\n        external \r\n        view \r\n        returns (bool) \r\n    {\r\n        if (!mintingEnabled) return false;\r\n        if (quantity == 0 || quantity > MAX_PER_TX) return false;\r\n        if (_totalMinted() + quantity > MAX_SUPPLY) return false;\r\n        if (walletMints[account] + quantity > MAX_PER_WALLET) return false;\r\n        return true;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}